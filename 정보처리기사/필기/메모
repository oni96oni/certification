01. 나선형모델 -> 폭포수
02. 구현 -> 설계
03. 폭포수모델
04. 애자일 -> 구조적 방법론
05. 1:o tdd
    2:ㅈ refactioring
    3:ㄷ CI
06. 스크럼
07. 델파이
08. 기능점수
09. PERT
10. 14일 (임계경로 : 제일 오래걸리는길)
11. 200

01. Observer패턴
02. 요구사항에는 기능적, 비기능적요구사항이 있다.
03. 디자인팽터은 생성, 구조, 행위
04. 팩토리 메서드패턴은 상위 클래스에서 인터페이스만 정의, 실제생성은 서브클래스에서
05. 반복적으로 사용되는 객체들의 상호 작용을 패턴화 -> 행위
06. Bridge : 추상, 실제구현부분 독립 확장가능, Obeserver : 객체 상태 변경시 그 객체 의존하는 다른객체 연락
07. 객체의 대리자를 이용하여 원객체 작업처리 : Proxy
08. Singleton : 전역변수를 사용하지않고 객체를 하나만 생성 , Vistor : 

01. 프로세스뷰 : 시스템의 비기능적속성, 자원 효율적인 사용, 병행 실행, 비동기, 이벤트 처리등을 표현, 개발자 시스템 통합자 관점
02. 계층화패턴 : 서로 마주 보는 두 개의 계층 사이에서만 상호작용이루어짐
03. MVC : 모델 뷰 컨트롤러, 각 부분 서로 영향X 개발작업수행가능
04. Singleton : 전역변수사용x, 객체하나만 생성, 생성된 객체 어디서든지 참조
05. 팩토리메서드 : 상위클래스에서 인터페이스 정의, 하위클래스에서 인스턴스 생성
06. 빌더패턴 : 복잡한 인스턴스 조립, 복합객체생성시 객체 생성과 객체 구현방법을 분리
07. 전략패턴 : 알고리즘군정의, 각각 캡슐화 필요할떄 서로 교환해서 사용
08. 템플릿메서드 : 일부분 서브클래스로 캡슐화, 전체 구조 변경하지않는 패턴
09. 어댑터패턴 : 기존에 생성된 클래스 재사용, 중간다리 인터페이스
10. 기능 1,3 비기능 2,4
11. 요구사항도출
12. 브레인스토밍
13. 비정명 명세
14. 요구사항 명세서
15. 인스펙션

01. 소프트웨어 생명주기모델 : 폭 프 나 
02. 요설구테유
03. 나선형모델 : 위험최소화 
04. 정보시스템 개발에 필요한 관리 절차와 작업기법 : 정보공학방법론
05. 메타포어 : 공통적인 이름체계 통해 고객과 개발자 간의 의사소통 원활
06. XP 스크럼 린
07. 주 공정법(CPM) : 얽혀있는 프로젝트 일정 계산기법
08. 10000 % 5 % 250 = 8개월
09. 아키텍처 기술표준?
10. 4+1뷰 : 설계자, 개발자관점 = 논리뷰
11. 데이터스트림 : 파이프-필터패턴
12. 경험없는조직 비용평가모델 : SAAM
13. 빌더패턴 : 복잡인스턴스, 복합객체, 객체 생성과 구현방법분리
14. 팩토리메서드패턴 : 상위 클래스에서 객체생성 인터페이스 정의, 하위클래스에서 인스턴스 생성, 오버라이딩
15. 요구사항 분석
16. 기능 : 업무 1 4 , 비기능 : 개발 2 3
17. 요구사항 도출, 요구사항 명세 (요구사항 도 분 명 확)
18. 롤플레잉 : 연기
19. 직접대화 : 인터뷰
20. 비정형 : 자연어, 정형 : 수학
21. 워크스루 : 검토자료 회의전 사전검토

화면설계

UI 요구사항 확인
01. ui설계원칙 : 직유학유
02. 쉽게 이해하고 사용가능해야한다 : 직관성
03. UX, UI
04. GUI : 사용자가 그래픽 환경기반으로 이용
05. NUI : 신체 활용 사용자 인터페이스

01. OUI : 유기적 상호작용기반 인터페이스, 모든사물이 입출력장치
02. 인터페이스 설계기본원칙 : 학습성, 유연성
03. 이해관계자 화면구성협의 ui 화면 설계방식 : 와이어 프레임
04. 사용성의 부특성에는 이해, 학습, 운용성이있다.
05. ui설계지침 주요기능을 메인화면에 노출 쉬운조작 : 가시성
06. 스왓분석 : 강점 약점 기회 위협 경영전략, 시나리오설계 : 시나리오플래닝
07. 디자이너 개발자 최종참고 문서 : 스토리보드

UI 설계
01. 폴더 모양 패키지와 점선 : 패키지 다이어그램
02. 집합관계 : 하나의 사물이 다른 사물에 포함, 일반화관계 : 하나의 사물이 다른 사물에 비해 더 일반적인지 표현
03. 클래스다이어그램 : 속성, 메서드를 포함하는 다이어그램
04. UML 관계, 클래스, 인터페이스

01. 일반화 관계 : 일반적인지 구체적인지 표현
02. 커뮤니케이션 다이어그램 : 시스템이나 객체들이 메세지주고받음, 상태 다이어그램 : 하나의 객체가 자신이 속한클래스의 상태변화표현
03. UML구성요소 : 사물, 관계, 다이어그램
04. 시퀀스 다이어그램 : 객체간 상호작용을 메시지 흐름으로 표현
05. 반드시 포함관계 : include, 실행할수도안할수도 : exclued
06. 컴포넌트 다이어그램

01. GUI : 사용자가 편리하게 사용, NUI : 인간의 자연스러운 신체움직임, CI : 명령어를 텍스트로 입력, WI : 인터넷과 웹 브라우저를 통해 웹페이지를 열람
02. UI 설계지침 가시성 : 주요 기능 메인화면에 노출
03. 경영전략기법 : 시나리오플래닝 : 불확실성이 높은 상황 예측하여 제거
04. 강점,약점,기회,위협 : SWOT, 고객 자사 경쟁사 비교 : 3C
05. 사용성 테스트 : 테스트하며 사용자의 요구사항 행동관찰
06. 와이어프레임 < 스토리보드 < 프로토타입
07. 와이어프레임 : 서비스의 간략한, 프로토타입 : 전체적인기능 간략
08. UML구성요소 : 명사 또는 동사 : 사물, 형용사 부사 : 관계
09. 활동 다이어그램 : 객체의 처리 흐름을 순서대로 표현
10. 클래스의 구조적 특성에 이름을 붙인것 : 속성
11. 시퀀스 다이어그램 : 객체, 생명선, 활성화, 메시지

데이터 입출력

데이터 저장소
01. 슈퍼키 : 유일성, 후보키 : 유일성, 최소
02. 데이터모델링절차 : 요개논물 : 요구사항분석 - 개념적 데이터 모델링 - 논리적 데이터 모델링 - 물리적 데이터 모델링
03. db설계절차 : 테이블정의서 : 물리적설계, E-R다이어그램 : 개념적설, 트랜잭션인터페이스 : 논리적설계
04. 데이터모델에 표시해야할 요소 : 논리적데이터구조, 연산, 제약조건
05. 카디널리티 = 튜플 = 가로줄개수, 디그리 : 속성의수 = 세로줄개수
06. 정규화단계 : 원부이 결다조 : 원자화, 부분함수 종속제거, 이행함수 종속제거, 다치종속제거, 조인종속제거
07. 반정규화
08. 관계대수기호 (셀프조디) 디비전
09. 이상현상 : 삽삭갱 : 삽입, 삭제, 갱신이상
10. 삭제이상 : 정보 삭제 시 원치않는 다른정보가 같이 삭제되는 이상현상
11. 내절해비 : 관계 내수는 절차적언어, 관계 해석은 비절차적언
12. 프로젝트연산자(파이모양)는 릴레이션R에서 주어신 속성의 튜플을 반환
13. 합집합 : U, 차집합 : -, 카티션 프로덕트 : X, 프로젝트 : 파이, 조인 : |X|
14. 개체 집합의 단일 속성 : 동그라미, 관계 집합의 속성 : 동그라미두개, 개체 집합과 속성을 이어준다 : 실선, 개체집합과 관계집합을 이어준다 : 실선, 관계집합 : 마름모
15. 함수종속 : 부완이 : 부분(partial), 완전(Full), 이행(Transitive)함수종속 존재 
16. 비정규화 : 정규화된 데이터베이스의 단계를 낮추는것?
17. 튜플 : 테이블 내의 행, 릴레이션 인스턴스 : 릴레이션에 실제로 저장된 데이터의 집합, 카디널리티 : 특정 데이터집합의 유니크한 값의 개수
18. 데이터베이스 구축 프로세스 : 요개논물구 : 요구사항 분석 - 개념적설계 - 논리적설계 - 물리적설계 - 구현
19. 관계대수연산자 기호 : join : |x|, project : 파이, select : 시그마, division : 나누기 
20. 참조무결성 제약조건 : 릴레이션과 릴레이션 사이에 대해 참조의 일관성을 보장하기 위한 조

01. 논리 데이터 모델링의 속성 구성요소 : 개속관 : 개체, 속성, 관계
02. 데이터 모델 : 개체-관계(E-R) 모델, 개체, 속성, 관계로 기술
03. E-R 다이어그램 기호 : 관계 : 마름모, 단일값속성 : 동그라미
04. 정규화 : 관계형 데이터 모델에서 데이터의 중복성 제거, 이상현상 방지, 무손실 분해
05. 정규화 2단계 : 부분관계를 별도의 테이블로 나눔
06. 데이터베이스 이상현상 : 데이터의 중복성으로 인해 발생
07. 정규화 1단계 릴레이션에 여러데이터
08. 모델링 기법 : 논리모델을 적용 상세화 : ?
09. Foreign key : 테이블간의 참조데이터 무결성, 릴레이션의 컬럼이 다른 릴레이션의 기본키로 이
10. 관계형 데이터베이스의 인덱스 : 전체 데이터 검색없이 빠르게 조회
11. 파티셔닝기법 : 연솟적인 숫자, 날짜 : 레인지파티셔닝

데이터베이스 기초 활용 139p

01. 데이터마이닝 : 데이터를 모아서 의사결정
02. 하둡 : pc를 모아 가상화하여 스토리지를 형성하여 데이터 병렬처리를 가능하게하는 기술

01. 데이터베이스의정의 : 통합된데이터 : 자료의중복제거
02. RDBMS : 데이터를 상하종속적인 관계로 다룸, 접근은 빠르나 변화대응에 힘듬
03. NOSQL : key-value Store : Unique key 하나의 value, column family data store : key안에 (column, value)조합으로 여러개 필드가짐, document store : value의 data 타입이 document, graph store : 시멘틱웹과 온톨로지분야
04. ER다이어그램 : 네모 : 개체, 동그라미 : 속성
05. 분산컴퓨팅, 하둡
06. 빅데이터의 특성 3V : Velocity, Variety, Volume
07. NoSQL : 조인불가, 수평확장용이
08. NoSQL의 특성중 BASE : soft-state, basically available, eventually consistency
09. key안에 조합(column, value)으로 된 여러개의 필드를 갖는 db : NoSQL
10. 데이터마이닝
11. 데이터마이닝의 주요기법 : 분연연 분석 연관 연속

01. 논리데이터모델링 속성 : 개속관 : 개체, 속성, 관계
02. 정규화단계 : 모든 결정자가 후보키, 결정자함수종속성 제거 -> 보이스-코드 정규형
03. 1정규화 : 테이블내 속성값을 원자값으로 구성
04. 해시파티셔닝 : 해시값에 의한 균등한 파티셔닝
05. 개체관계모델의 개념 : 개체간의 관계를 도식화
06. 레인지파티셔닝 : 연속적인 숫자, 날짜를 기준으로 파티셔닝
07. 데이터베이스는 통저운공이다. 통합,저장,운영,공유
08. 데이터베이스의 특징 : 실계동네. 실시간 접근성, 계속적인 변화, 동시 공용, 내용 참조
09. 빅데이터의 개념 : 다량의 데이터로 분석하여 최선의 값을 도출
10. 빅데이터의 특징 3v : volume, velocity, variety
11. NoSQL의 특징 : join불가, 수평확장용이
12. 데이터 베이스 BASE : basically available, soft-state, eventually consistence
13. column family data store : key value구조에서 key가 column value로 
14. 텍스트마이닝 : 대량의 텍스트 데이터로부터~
15. 개체 무결성 : 같은 pk를 못가짐, pk는 null이 안된다.
16. 카티션 프로덕트 : 두 릴레이션으로 조합가능한 모든 릴레이션을 구함

통합구현 150p

01. WSDL, SOAP 프로토콜을 이용한 시스템간 연계 : WEB SERVICE, 서로다른 애플리케이션에서 인터페이스 : API, 현재 페이지에서 다른페이지로 이동 : 하이퍼링크
02. JDBC : 자바에서 데이터베이스에 접속할수있게해주는 API

내외부연계모듈구현 157p

01. SOAP : HTTP, HTTPS, SMTP를 통해서 XML기반의 데이터를 송수신하는 프로토콜
02. EAI의 유형 : 포허매하 : 포인트 투 포인트, 허브 앤 스포크, 메시지 버스, 하이브리드
03. 프로세스간 통신기술 : IPC : 공소세메 : 공유메모리, 소켓, 세마포어, 메세지큐
04. EAI : 애플리케이션간의 정보 I/F
05. WSDL : 웹서비스명, 제공위치, 메시지 포맷, 프로토콜 정보 등 XML 형식으로 구성된 언어
06. HTTP : 요청과 응답에 의해 처리(GET,POST등), HyperText : 다른사이트로 이동, HTML : 마크업언어 
07. LOD : 전세계 오픈된 정보를 하나로 묶음, LinkData와 OpenData 합친말

01. EAI : 비표준 어댑터를 배포하여 통합하는 방식
02. EAI구축 유형 : 포인트 투 포인트, 메시지 버스, 하이브리드, 허브 앤 스포크
03. ESB : 미들웨어를 중심으로 각각 프로토콜이 호환할 수 있도록 애플리케이션의 느슨한 결합을 지원
04. WSDL : SOAP + XML

01. JDBC Driver, JDBC Driver manager
02. 소켓 : 서버와 클라이언트가 통신할 수 있게 해주는 프로그램
03. 포인트 투 포인트 : 솔루션을 구매하지 않고도 개발자간의 커뮤니케이션을 통해서 통합

인터페이스 구현 168p

01. XML : W3C에 의해 개발, 브라우저간의 호환안되는 문제 해결, SGML 복잡함 해결
02. JSON : 속성 - 값으로 이루어진 데이터 포멧, AJAX에서 주로 사용
03. AJAX : 브라우저가 갖고있는 XMLHttpRequest를 이용, 전체페이지 새로고침 없이 일부분 새로고침
04. AJAX : 위와 동

01. JSON : AJAX에서 주로 사용하는 데이터 포멧, XML 대체
02. XML : 인간과 기계 모두 이해가능, 사용자가 직접 문서 태그 정의, 송수신간 편의성을 위해 데이터 구조를 동일한 형태로 정의
03. XMLHttpRequest : 웹브라우저와 서버간의 메서드가 데이터를 전송하는 객체 폼의 API, DOM : XML문서를 트리구조로 접근할수 있게해줌, 
04. REST : 자원의 존재/상태 정보를 표준화된 HTTP 메서드 주고받는 웹 아키텍쳐

01. 메시지 버스 : 어플리케이션 사이 미들웨어(버스)를 두어 미들웨어 통합방식, 하이브리드 : 메시지버스와 허브 앤 스포크 동시사용
02. 내부 외부 연계모듈, ESB : 서로 다른 플랫폼과 애플리케이션을 하나의 시스템으로 관리, 기업간의 서비스 교환을 위해 표준API로 한다.
03. JSON : 속성 - 값 쌍으로 이루어짐, REST : 분산 하이퍼미디어 환경에서 자원의 존재/사태 정보를 표준화된 HTTP 메서드로 주고받는 웹 아키텍쳐
04. XML의 개념에 대해서 약술 : 표준 마크업 언어. HTML의 단점보완, SGML의 단점 보완
05. XPATH이용 : XSTL
06. REST 구성요소 : 리소스(자원), 메소드(처리), 메시지

프로그래밍 언어 활용 180p

이 외 문제 코딩문제
04. 헝가리안 표기법 : 접두어에 자료형을 붙임
19. *p = p[0]
    *a = a[0]

20. qwe

21. a : %, b : 10
    or a : &, b : 2
    or a : &, b : 1

    중복정답이 가능한 문제

22. n[i+1%5] 

23. 73+95+82 = 168 + 82 = 250 / 30 8.xxx 
    B C D

24. 
    isWhat
    point

    0 5 
    1 6
    2 3 


    2
    1
    3
    4
    6
    5

25. gets 함수는 c에서 입력받는함수
    한글은 문자형2개 변수에 1글자 저장
    
    char *soojebi() {
        gets(n);
        return n;
    }

    -> n의 주소값 리턴 -> (&n[0]) -> n[0]의 주소값

26. 
    1. m % 1000
    2. (m % 1000) % 500
    3. (m % 500) % 100
    4. (m % 100) % 10

27.
    sizeof 함수는 배열의 전체크기를 구하는 함수이다.
    
    프로그래머가 만든 소스코드에서 메모리공간을 실제 몇byte를 차지하는지 확인

    int는 4byte이므로 int arr[] = {64, 25, 12, 22,11};
    의 경우 sizeof(arr) == 20byte가 된다.

    j 1
    i 0

    >

28.
    2023 / 4 505

29. 
    if문안에 1 == true
            0 == false

    완전수 구하는 문제
    자기자신을 제외한 양의 약수를 더했을때 자기 자신이 되는 양의 정수
    6, 28, 496 등이 있다.

    perfect_number
    : ex 10
    1 5 ++
    5%1..2..3..4..5
    5

    소수구하는문제?
    아니다.

    34?

30. 
    구조체 멤버에 접근하기 위해ㅓ는 화살표 연산자를 사용
    구조체 포인터 -> 멤버 변수 이름

31. 
    fx7

    fx6 + fx4

    fx5 + fx3 + fx3 + fx1

    fx4 + fx2
        fx3 + fx1 + fx1 + fx-1
            fx2 + fx0 + 1 + 1 - 1
            fx1 + fx-1 + 0 + 1
            1 - 1 + 1
            == 1
    fx2 + fx0
    0     0
    fx2 + fx0

    1

    == 2

32.
    char* p = "KOREA";
    
    KOREA
    OREA
    K
    E
    O

8.
    1 2 3  4 5 6
    p[0]+1 == arr[0][1] == 2
    p[1]+2 == arr[1][2] == 6

    arr[1][0] == 4
    arr[1][1] == 5